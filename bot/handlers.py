from aiogram import Router, types, F
from aiogram.filters import CommandStart
from keyboards import main_menu, get_recipes_keyboard, get_subscription_keyboard
from recipes.models import Recipe, BotUser
import random
import os
from states import SearchRecipe
from utils import check_and_use_access
from aiogram.types import (
    Message, 
    PreCheckoutQuery,
    ContentType,
    FSInputFile, 
    CallbackQuery, 
    LabeledPrice
)
from aiogram.fsm.context import FSMContext
from asgiref.sync import sync_to_async
from django.db.models.functions import Lower
from datetime import timedelta
from django.utils import timezone


router = Router()


SUBSCRIPTION_PRICE = 29900
SUBSCRIPTION_DURATION = 30


payment_router = Router()

@router.message(CommandStart())
async def cmd_start(message: types.Message):
    from recipes.models import BotUser
    user, created = await sync_to_async(BotUser.objects.get_or_create)(telegram_id=message.from_user.id)
    user.username = message.from_user.username
    await sync_to_async(user.save)()
    
    await message.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç FoodPlan –∏ —è –ø–æ–º–æ–≥—É —Ç–µ–±–µ –Ω–∞–π—Ç–∏ —Ä–µ—Ü–µ–ø—Ç –ø–æ –¥—É—à–µ. –í—ã–±–µ—Ä–∏ –æ–ø—Ü–∏—é –Ω–∏–∂–µ üëá",
        reply_markup=main_menu
        )


@router.message(F.text == "–û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É")
async def offer_subscription(message: types.Message):
    await message.answer(
        "–ü—Ä–µ–º–∏—É–º –ø–æ–¥–ø–∏—Å–∫–∞ –¥–∞–µ—Ç –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ä–µ—Ü–µ–ø—Ç–∞–º!\n"
        f"–°—Ç–æ–∏–º–æ—Å—Ç—å: 299 —Ä—É–± / {SUBSCRIPTION_DURATION} –¥–Ω–µ–π\n\n"
        "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
        reply_markup=get_subscription_keyboard()
    )


@router.callback_query(F.data == "buy_subscription")
async def buy_subscription(callback: types.CallbackQuery):
    await callback.bot.send_invoice(
        chat_id=callback.message.chat.id,
        title="–ü—Ä–µ–º–∏—É–º –ø–æ–¥–ø–∏—Å–∫–∞ FoodPlan",
        description=f"–î–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ä–µ—Ü–µ–ø—Ç–∞–º –Ω–∞ {SUBSCRIPTION_DURATION} –¥–Ω–µ–π",
        payload="month_sub",
        provider_token="1744374395:TEST:52fffc9e8301b69827ef",
        currency="RUB",
        prices=[LabeledPrice(label="–ü–æ–¥–ø–∏—Å–∫–∞", amount=SUBSCRIPTION_PRICE)],
        start_parameter="month_sub",
        photo_size=512,
        need_email=True,
        send_email_to_provider=True
    )
    await callback.answer()


@payment_router.pre_checkout_query()
async def process_pre_checkout_query(pre_checkout_query: PreCheckoutQuery):
    await pre_checkout_query.answer(ok=True)


@payment_router.message(F.content_type == ContentType.SUCCESSFUL_PAYMENT)
async def process_successful_payment(message: types.Message):     
    user, created = await sync_to_async(BotUser.objects.get_or_create)(
        telegram_id=message.from_user.id,
        defaults={'username': message.from_user.username}
    )

    user.is_subscribed = True
    user.subscription_end = timezone.now() + timedelta(days=SUBSCRIPTION_DURATION)
    await sync_to_async(user.save)()
        
    await message.answer(
        "üéâ –ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!\n"
        f"–î–æ—Å—Ç—É–ø –æ—Ç–∫—Ä—ã—Ç –¥–æ {user.subscription_end.strftime('%d.%m.%Y')}"
    )


@router.message(F.text == "–°–ª—É—á–∞–π–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç")
async def random_recipe(message: types.Message):
    user = await sync_to_async(BotUser.objects.get)(telegram_id=message.from_user.id)
    access = await sync_to_async(user.try_use_feature)()
    # acces = await check_and_use_access(message.from_user.id, message.from_user.username)
    if not access:
        await message.answer(
            "–í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ 3 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="–û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="buy_subscription")]
            ])
        )
        return
    
    
    
    recipes = await sync_to_async(list)(Recipe.objects.all())
    if not recipes:
        await message.answer("–í –Ω–∞—à–µ–π —Ä–µ—Ü–µ–ø—Ç–æ—Ç–µ–∫–µ –Ω–µ—Ç —Ä–µ—Ü–µ–ø—Ç–æ–≤ :(")
        return
    
    recipe = random.choice(recipes)
    
    photo_path = recipe.img_url.path 
    photo = FSInputFile(photo_path)
    
    caption = f"<b>{recipe.title}</b>\n\n{recipe.description}"
    buttons= [
        [types.InlineKeyboardButton(text="–ß—Ç–æ –∫—É–ø–∏—Ç—å?", callback_data=f"ingredients_{recipe.id}")],
        [types.InlineKeyboardButton(text="–°–ø–æ—Å–æ–± –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è", callback_data=f"instructions_{recipe.id}")],
    ]
    markup = types.InlineKeyboardMarkup(inline_keyboard=buttons)
    
    await message.answer_photo(photo=photo, caption=caption, parse_mode="HTML", reply_markup=markup)

    
@router.callback_query(F.data.startswith("ingredients_"))
async def show_ingredients(callback: types.CallbackQuery):
    recipe_id = int(callback.data.split("_")[1])
    recipe = await sync_to_async(Recipe.objects.get)(id=recipe_id)
    
    await callback.message.answer(f"<b>–ß—Ç–æ –∫—É–ø–∏—Ç—å:</b>\n{recipe.ingredients}", parse_mode="HTML")
    await callback.answer()


@router.callback_query(F.data.startswith("instructions_"))
async def show_instructions(callback: types.CallbackQuery):
    recipe_id = int(callback.data.split("_")[1])
    recipe = await sync_to_async(Recipe.objects.get)(id=recipe_id)
    
    await callback.message.answer(f"üë®<b>–°–ø–æ—Å–æ–± –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è:</b>\n{recipe.instructions}", parse_mode="HTML")
    await callback.answer()


@router.message(F.text == "–ù–∞–π—Ç–∏ —Ä–µ—Ü–µ–ø—Ç")
async def ask_recipe_name(message: types.Message, state: FSMContext):
    
    await state.set_state(SearchRecipe.waiting_for_recipe_name)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –±–ª—é–¥–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:")


@router.message(SearchRecipe.waiting_for_recipe_name)
async def search_recipe(message: types.Message, state: FSMContext):
    access = await check_and_use_access(message.from_user.id, message.from_user.username)
    if not access:
        await message.answer("–í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ 3 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞.")
        await state.clear()
        return

    @sync_to_async
    def get_matches(search_text: str):
        return [
            r for r in Recipe.objects.all()
            if search_text.lower() in r.title.lower()
        ]

    matches = await get_matches(message.text)

    if matches:
        await message.answer(f"–ù–∞–π–¥–µ–Ω–æ —Ä–µ—Ü–µ–ø—Ç–æ–≤: {len(matches)}", reply_markup=get_recipes_keyboard(matches))
    else:
        await message.answer("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ üò¢")

    await state.clear()


@router.callback_query(F.data.startswith("recipe_"))
async def send_recipe(callback: CallbackQuery):
    recipe_id = int(callback.data.split("_")[1])

    recipe = await sync_to_async(Recipe.objects.get)(id=recipe_id)

    photo_path = recipe.img_url.path
    photo = FSInputFile(photo_path)

    caption = f"<b>{recipe.title}</b>\n\n{recipe.description}"

    buttons = [
        [types.InlineKeyboardButton(text="–ß—Ç–æ –∫—É–ø–∏—Ç—å?", callback_data=f"ingredients_{recipe.id}")],
        [types.InlineKeyboardButton(text="–°–ø–æ—Å–æ–± –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è", callback_data=f"instructions_{recipe.id}")],
    ]
    markup = types.InlineKeyboardMarkup(inline_keyboard=buttons)

    await callback.message.answer_photo(photo=photo, caption=caption, parse_mode="HTML", reply_markup=markup)
    await callback.answer()